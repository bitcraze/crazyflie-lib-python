# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing

@typing.final
class Commander:
    r"""
    Commander subsystem wrapper
    """
    def send_setpoint_rpyt(
        self,
        roll: builtins.float,
        pitch: builtins.float,
        yaw_rate: builtins.float,
        thrust: builtins.int,
    ) -> None:
        r"""
        Sends a Roll, Pitch, Yawrate, and Thrust setpoint to the Crazyflie.

        By default, unless modified by [parameters](crate::subsystems::param::Param), the arguments are interpreted as:
        * `roll` - Desired roll angle (degrees)
        * `pitch` - Desired pitch angle (degrees)
        * `yawrate` - Desired yaw rate (degrees/second)
        * `thrust` - Thrust as a 16-bit value (0 = 0% thrust, 65535 = 100% thrust)

        Note: Thrust is locked by default for safety. To unlock, send a setpoint with `thrust = 0` once before sending nonzero thrust values.
        """
    def send_setpoint_position(
        self,
        x: builtins.float,
        y: builtins.float,
        z: builtins.float,
        yaw: builtins.float,
    ) -> None:
        r"""
        Sends an absolute position setpoint in world coordinates, with yaw as an absolute orientation.

        # Arguments
        * `x` - Target x position (meters, world frame)
        * `y` - Target y position (meters, world frame)
        * `z` - Target z position (meters, world frame)
        * `yaw` - Target yaw angle (degrees, absolute)
        """
    def send_setpoint_velocity_world(
        self,
        vx: builtins.float,
        vy: builtins.float,
        vz: builtins.float,
        yawrate: builtins.float,
    ) -> None:
        r"""
        Sends a velocity setpoint in the world frame, with yaw rate control.

        # Arguments
        * `vx` - Target velocity in x (meters/second, world frame)
        * `vy` - Target velocity in y (meters/second, world frame)
        * `vz` - Target velocity in z (meters/second, world frame)
        * `yawrate` - Target yaw rate (degrees/second)
        """
    def send_setpoint_zdistance(
        self,
        roll: builtins.float,
        pitch: builtins.float,
        yawrate: builtins.float,
        zdistance: builtins.float,
    ) -> None:
        r"""
        Sends a setpoint with absolute height (distance to the surface below), roll, pitch, and yaw rate commands.

        # Arguments
        * `roll` - Desired roll angle (degrees)
        * `pitch` - Desired pitch angle (degrees)
        * `yawrate` - Desired yaw rate (degrees/second)
        * `zdistance` - Target height above ground (meters)
        """
    def send_setpoint_hover(
        self,
        vx: builtins.float,
        vy: builtins.float,
        yawrate: builtins.float,
        zdistance: builtins.float,
    ) -> None:
        r"""
        Sends a setpoint with absolute height (distance to the surface below), and x/y velocity commands in the body-fixed frame.

        # Arguments
        * `vx` - Target velocity in x (meters/second, body frame)
        * `vy` - Target velocity in y (meters/second, body frame)
        * `yawrate` - Target yaw rate (degrees/second)
        * `zdistance` - Target height above ground (meters)
        """
    def send_setpoint_manual(
        self,
        roll: builtins.float,
        pitch: builtins.float,
        yawrate: builtins.float,
        thrust_percentage: builtins.float,
        rate: builtins.bool,
    ) -> None:
        r"""
        Sends a manual control setpoint for roll, pitch, yaw rate, and thrust percentage.

        If `rate` is false, roll and pitch are interpreted as angles (degrees). If `rate` is true, they are interpreted as rates (degrees/second).

        # Arguments
        * `roll` - Desired roll (degrees or degrees/second, depending on `rate`)
        * `pitch` - Desired pitch (degrees or degrees/second, depending on `rate`)
        * `yawrate` - Desired yaw rate (degrees/second)
        * `thrust_percentage` - Thrust as a percentage (0 to 100)
        * `rate` - If true, use rate mode; if false, use angle mode
        """
    def send_stop_setpoint(self) -> None:
        r"""
        Sends a STOP setpoint, immediately stopping the motors. The Crazyflie will lose lift and may fall.
        """
    def send_notify_setpoint_stop(
        self, remain_valid_milliseconds: builtins.int
    ) -> None:
        r"""
        Notify the firmware that low-level setpoints have stopped.

        This tells the Crazyflie to drop the current low-level setpoint priority,
        allowing the High-level commander (or other sources) to take control again.

        # Arguments
        * `remain_valid_milliseconds` - How long (in ms) the last low-level setpoint
          should remain valid before it is considered stale. Use `0` to make the
          hand-off immediate; small non-zero values can smooth transitions if needed.
        """

@typing.final
class Console:
    r"""
    Access to the console subsystem

    The Crazyflie has a text console that is used to communicate various information
    and debug message to the ground.
    """
    def get_lines(self) -> builtins.list[builtins.str]:
        r"""
        Get console lines as they arrive

        This function returns console lines line-by-line. It buffers lines internally
        and returns up to 100 lines per call with a 10ms timeout per line.

        The lib keeps track of the console history since connection, so the first
        call to this function will return all lines received since connection.

        Returns:
            List of console output lines (up to 100 with 10ms timeout)
        """

@typing.final
class Crazyflie:
    r"""
    Wrapper for the Crazyflie struct

    This provides a Python interface to the Rust Crazyflie implementation.
    Since the Rust library is async, we wrap it with a Tokio runtime.
    """
    @staticmethod
    def connect_from_uri(uri: builtins.str) -> Crazyflie:
        r"""
        Connect to a Crazyflie from a URI string

        Args:
            uri: Connection URI (e.g., "radio://0/80/2M/E7E7E7E7E7")

        Returns:
            Connected Crazyflie instance
        """
    def disconnect(self) -> None:
        r"""
        Disconnect from the Crazyflie
        """
    def commander(self) -> Commander:
        r"""
        Get the commander subsystem
        """
    def console(self) -> Console:
        r"""
        Get the console subsystem
        """
    def high_level_commander(self) -> HighLevelCommander: ...
    def log(self) -> Log:
        r"""
        Get the log subsystem
        """
    def param(self) -> Param:
        r"""
        Get the param subsystem
        """
    def platform(self) -> Platform:
        r"""
        Get the platform subsystem
        """

@typing.final
class HighLevelCommander:
    def set_group_mask(self, group_mask: builtins.int) -> None:
        r"""
        Set the group mask for the high-level commander.

        # Arguments
        * `group_mask` - The group mask to set. Use `ALL_GROUPS` to set the mask for all Crazyflies.
        """
    def take_off(
        self,
        height: builtins.float,
        yaw: typing.Optional[builtins.float],
        duration: builtins.float,
        group_mask: typing.Optional[builtins.int],
    ) -> None:
        r"""
        Take off vertically from the current x-y position to the given target height.

        # Arguments
        * `height` - Target height (meters) above the world origin.
        * `yaw` - Target yaw (radians). Use `None` to maintain the current yaw.
        * `duration` - Time (seconds) to reach the target height. This method blocks for this duration.
        * `group_mask` - Bitmask selecting which Crazyflies to command. Use `None` for all Crazyflies.
        """

@typing.final
class Log:
    r"""
    Access to the Crazyflie Log Subsystem

    This struct provides functions to interact with the Crazyflie Log subsystem.
    """
    def names(self) -> builtins.list[builtins.str]:
        r"""
        Get the names of all the log variables

        The names contain group and name of the log variable formatted as
        "group.name".
        """
    def get_type(self, name: builtins.str) -> builtins.str:
        r"""
        Return the type of a log variable or an Error if the parameter does not exist.

        Args:
            name: Log variable name

        Returns:
            Type as string (e.g., "u8", "i16", "f32")
        """
    def create_block(self) -> LogBlock:
        r"""
        Create a Log block

        This will create a log block in the Crazyflie firmware and return a
        LogBlock object that can be used to add variable to the block and start
        logging

        This function can fail if there is no more log block ID available: each
        log block is assigned a 8 bit ID by the lib and so far they are not
        re-used. So during a Crazyflie connection lifetime, up to 256 log
        blocks can be created. If this becomes a problem for any use-case, it
        can be solved by a more clever ID generation algorithm.

        The Crazyflie firmware also has a limit in number of active log block,
        this function will fail if this limit is reached. Unlike for the ID, the
        active log blocks in the Crazyflie are cleaned-up when the LogBlock
        object is dropped.

        Returns:
            A new LogBlock instance that can have variables added to it
        """

@typing.final
class LogBlock:
    r"""
    Log Block

    This object represents an IDLE LogBlock in the Crazyflie.

    If the LogBlock object is dropped or its associated LogStream, the
    Log Block will be deleted in the Crazyflie freeing resources.
    """
    def add_variable(self, name: builtins.str) -> None:
        r"""
        Add a variable to the log block

        A packet will be sent to the Crazyflie to add the variable. The variable is logged in the same format as
        it is stored in the Crazyflie (ie. there is no conversion done)

        This function can fail if the variable is not found in the toc or of the Crazyflie returns an error
        The most common error reported by the Crazyflie would be if the log block is already too full.

        Args:
            name: Variable name (e.g., "stateEstimate.roll")
        """
    def start(self, period_ms: builtins.int) -> LogStream:
        r"""
        Start log block and return a stream to read the value

        Since a log-block cannot be modified after being started, this function
        consumes the LogBlock object and return a LogStream. The function
        LogStream.stop() can be called on the LogStream to get back the LogBlock object.

        This function can fail if there is a protocol error or an error
        reported by the Crazyflie. In such case, the LogBlock object will be
        dropped and the block will be deleted in the Crazyflie

        Args:
            period_ms: Sampling period in milliseconds (10-2550)

        Returns:
            A LogStream for reading data
        """

@typing.final
class LogStream:
    r"""
    Log Stream

    This object represents a started log block that is currently returning data
    at regular intervals.

    Dropping this object or the associated LogBlock will delete the log block
    in the Crazyflie.
    """
    def next(self) -> dict:
        r"""
        Get the next log data from the log block stream

        This function will wait for the data and only return a value when the
        next data is available.

        This function will return an error if the Crazyflie gets disconnected.

        Returns:
            Dictionary with timestamp and variable values
        """
    def stop(self) -> LogBlock:
        r"""
        Stops the log block from streaming

        This method consumes the stream and returns back the log block object so that it can be started again later
        with a different period.

        This function can only fail on unexpected protocol error. If it does, the log block is dropped and will be
        cleaned-up next time a log block is created.

        Returns:
            The original LogBlock that can be restarted
        """

@typing.final
class Param:
    r"""
    Access to the Crazyflie Param Subsystem

    This struct provides methods to interact with the parameter subsystem.

    The Crazyflie exposes a param subsystem that allows to easily declare parameter
    variables in the Crazyflie and to discover, read and write them from the ground.

    Variables are defined in a table of content that is downloaded upon connection.
    Each param variable have a unique name composed from a group and a variable name.
    Functions that accesses variables, take a `name` parameter that accepts a string
    in the format "group.variable"

    During connection, the full param table of content is downloaded form the
    Crazyflie as well as the values of all the variable. If a variable value
    is modified by the Crazyflie during runtime, it sends a packet with the new
    value which updates the local value cache.
    """
    def names(self) -> builtins.list[builtins.str]:
        r"""
        Get the names of all the parameters

        The names contain group and name of the parameter variable formatted as
        "group.name".
        """
    def get_type(self, name: builtins.str) -> builtins.str:
        r"""
        Get the type of a parameter

        Returns the type string of the parameter (e.g., "u8", "f32", "i16").

        # Arguments
        * `name` - Parameter name in format "group.name"

        # Returns
        String representing the parameter type
        """
    def get(self, name: builtins.str) -> int | float:
        r"""
        Get param value

        Get value of a parameter. This function takes the value from a local
        cache and so is quick.

        # Arguments
        * `name` - Parameter name in format "group.name"

        # Returns
        Parameter value (int or float depending on parameter type)
        """
    def set(self, name: builtins.str, value: int | float) -> None:
        r"""
        Set a parameter value

        Sets a parameter to the given value. The value is automatically converted
        to match the parameter's type. Returns an error if the parameter does not
        exist or if the value cannot be converted to the parameter's type without
        loss of information.

        # Arguments
        * `name` - Parameter name in format "group.name"
        * `value` - New parameter value (int or float)

        # Errors
        Returns an error if:
        - The parameter does not exist
        - The value is out of range for the parameter type
        - The value cannot be represented accurately (e.g., fractional value for integer param)
        """

@typing.final
class Platform:
    r"""
    Access to platform services

    The platform CRTP port hosts a couple of utility services. This range from fetching the version of the firmware
    and CRTP protocol, communication with apps using the App layer to setting the continuous wave radio mode for
    radio testing.
    """
    def get_protocol_version(self) -> builtins.int:
        r"""
        Fetch the protocol version from the Crazyflie

        The protocol version is updated when new message or breaking change are
        implemented in the protocol.
        Compatibility is checked at connection time.
        """
    def get_firmware_version(self) -> builtins.str:
        r"""
        Fetch the firmware version

        If this firmware is a stable release, the release name will be returned for example ```2021.06```.
        If this firmware is a git build, between releases, the number of commit since the last release will be added
        for example ```2021.06 +128```.
        """
    def get_device_type_name(self) -> builtins.str:
        r"""
        Fetch the device type.

        The Crazyflie firmware can run on multiple device. This function returns the name of the device. For example
        ```Crazyflie 2.1``` is returned in the case of a Crazyflie 2.1.
        """
    def set_continuous_wave(self, activate: builtins.bool) -> None:
        r"""
        Set radio in continuous wave mode

        If activate is set to true, the Crazyflie's radio will transmit a continuous wave at the current channel
        frequency. This will be active until the Crazyflie is reset or this function is called with activate to false.

        Setting continuous wave will:
         - Disconnect the radio link. So this function should practically only be used when connected over USB
         - Jam any radio running on the same frequency, this includes Wifi and Bluetooth

        As such, this shall only be used for test purpose in a controlled environment.
        """
    def send_arming_request(self, do_arm: builtins.bool) -> None:
        r"""
        Send system arm/disarm request

        Arms or disarms the Crazyflie's safety systems. When disarmed, the motors
        will not spin even if thrust commands are sent.

        # Arguments
        * `do_arm` - true to arm, false to disarm
        """
    def send_crash_recovery_request(self) -> None:
        r"""
        Send crash recovery request

        Requests recovery from a crash state detected by the Crazyflie.
        """
