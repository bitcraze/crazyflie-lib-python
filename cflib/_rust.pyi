# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing

@typing.final
class AppChannel:
    r"""
    Bidirectional communication channel with Crazyflie apps

    The app channel provides both send and receive capabilities for custom
    communication with apps running on the Crazyflie firmware. Packets are
    limited to 31 bytes (APPCHANNEL_MTU).
    """
    def send(self, data: typing.Sequence[builtins.int]) -> None:
        r"""
        Send a data packet to the Crazyflie app

        Sends raw bytes to a custom app running on the Crazyflie. The packet
        must not exceed 31 bytes (APPCHANNEL_MTU).

        # Arguments
        * `data` - Bytes to send (maximum 31 bytes)

        # Raises
        * ValueError - If data exceeds 31 bytes
        """
    async def receive(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Receive buffered data packets from the Crazyflie app

        Returns all buffered packets received from the Crazyflie app. This
        function will return up to 100 packets with a 10ms timeout per packet.

        The library keeps track of all packets received since the channel was
        acquired, so the first call may return multiple buffered packets.

        # Returns
        * List of received data packets (each up to 31 bytes)
        """

@typing.final
class Commander:
    r"""
    Commander subsystem wrapper
    """
    async def send_setpoint_rpyt(
        self,
        roll: builtins.float,
        pitch: builtins.float,
        yaw_rate: builtins.float,
        thrust: builtins.int,
    ) -> None:
        r"""
        Sends a Roll, Pitch, Yawrate, and Thrust setpoint to the Crazyflie.

        By default, unless modified by [parameters](crate::subsystems::param::Param), the arguments are interpreted as:
        * `roll` - Desired roll angle (degrees)
        * `pitch` - Desired pitch angle (degrees)
        * `yawrate` - Desired yaw rate (degrees/second)
        * `thrust` - Thrust as a 16-bit value (0 = 0% thrust, 65535 = 100% thrust)

        Note: Thrust is locked by default for safety. To unlock, send a setpoint with `thrust = 0` once before sending nonzero thrust values.
        """
    async def send_setpoint_position(
        self,
        x: builtins.float,
        y: builtins.float,
        z: builtins.float,
        yaw: builtins.float,
    ) -> None:
        r"""
        Sends an absolute position setpoint in world coordinates, with yaw as an absolute orientation.

        # Arguments
        * `x` - Target x position (meters, world frame)
        * `y` - Target y position (meters, world frame)
        * `z` - Target z position (meters, world frame)
        * `yaw` - Target yaw angle (degrees, absolute)
        """
    async def send_setpoint_velocity_world(
        self,
        vx: builtins.float,
        vy: builtins.float,
        vz: builtins.float,
        yawrate: builtins.float,
    ) -> None:
        r"""
        Sends a velocity setpoint in the world frame, with yaw rate control.

        # Arguments
        * `vx` - Target velocity in x (meters/second, world frame)
        * `vy` - Target velocity in y (meters/second, world frame)
        * `vz` - Target velocity in z (meters/second, world frame)
        * `yawrate` - Target yaw rate (degrees/second)
        """
    async def send_setpoint_zdistance(
        self,
        roll: builtins.float,
        pitch: builtins.float,
        yawrate: builtins.float,
        zdistance: builtins.float,
    ) -> None:
        r"""
        Sends a setpoint with absolute height (distance to the surface below), roll, pitch, and yaw rate commands.

        # Arguments
        * `roll` - Desired roll angle (degrees)
        * `pitch` - Desired pitch angle (degrees)
        * `yawrate` - Desired yaw rate (degrees/second)
        * `zdistance` - Target height above ground (meters)
        """
    async def send_setpoint_hover(
        self,
        vx: builtins.float,
        vy: builtins.float,
        yawrate: builtins.float,
        zdistance: builtins.float,
    ) -> None:
        r"""
        Sends a setpoint with absolute height (distance to the surface below), and x/y velocity commands in the body-fixed frame.

        # Arguments
        * `vx` - Target velocity in x (meters/second, body frame)
        * `vy` - Target velocity in y (meters/second, body frame)
        * `yawrate` - Target yaw rate (degrees/second)
        * `zdistance` - Target height above ground (meters)
        """
    async def send_setpoint_manual(
        self,
        roll: builtins.float,
        pitch: builtins.float,
        yawrate: builtins.float,
        thrust_percentage: builtins.float,
        rate: builtins.bool,
    ) -> None:
        r"""
        Sends a manual control setpoint for roll, pitch, yaw rate, and thrust percentage.

        If `rate` is false, roll and pitch are interpreted as angles (degrees). If `rate` is true, they are interpreted as rates (degrees/second).

        # Arguments
        * `roll` - Desired roll (degrees or degrees/second, depending on `rate`)
        * `pitch` - Desired pitch (degrees or degrees/second, depending on `rate`)
        * `yawrate` - Desired yaw rate (degrees/second)
        * `thrust_percentage` - Thrust as a percentage (0 to 100)
        * `rate` - If true, use rate mode; if false, use angle mode
        """
    async def send_stop_setpoint(self) -> None:
        r"""
        Sends a STOP setpoint, immediately stopping the motors. The Crazyflie will lose lift and may fall.
        """
    async def send_notify_setpoint_stop(
        self, remain_valid_milliseconds: builtins.int
    ) -> None:
        r"""
        Notify the firmware that low-level setpoints have stopped.

        This tells the Crazyflie to drop the current low-level setpoint priority,
        allowing the High-level commander (or other sources) to take control again.

        # Arguments
        * `remain_valid_milliseconds` - How long (in ms) the last low-level setpoint
          should remain valid before it is considered stale. Use `0` to make the
          hand-off immediate; small non-zero values can smooth transitions if needed.
        """

@typing.final
class CompressedSegment:
    r"""
    A segment in a compressed trajectory.

    Each axis can have 0, 1, 3, or 7 polynomial coefficients.
    Spatial values are encoded as millimeters (±32.767m range).
    Yaw values are encoded as 1/10th degrees.
    """
    @property
    def duration(self) -> builtins.float:
        r"""
        Duration of this segment in seconds
        """
    @property
    def x(self) -> builtins.list[builtins.float]:
        r"""
        X polynomial coefficients (0, 1, 3, or 7 elements)
        """
    @property
    def y(self) -> builtins.list[builtins.float]:
        r"""
        Y polynomial coefficients (0, 1, 3, or 7 elements)
        """
    @property
    def z(self) -> builtins.list[builtins.float]:
        r"""
        Z polynomial coefficients (0, 1, 3, or 7 elements)
        """
    @property
    def yaw(self) -> builtins.list[builtins.float]:
        r"""
        Yaw polynomial coefficients (0, 1, 3, or 7 elements)
        """
    def __new__(
        cls,
        duration: builtins.float,
        x: typing.Sequence[builtins.float],
        y: typing.Sequence[builtins.float],
        z: typing.Sequence[builtins.float],
        yaw: typing.Sequence[builtins.float],
    ) -> CompressedSegment:
        r"""
        Create a new compressed segment.

        Each element list must have 0, 1, 3, or 7 values.
        """

@typing.final
class CompressedStart:
    r"""
    Starting point for a compressed trajectory.

    Defines the initial position (x, y, z in meters) and yaw (radians).
    Spatial range: approximately ±32.767 meters.
    Packs to 8 bytes.
    """
    @property
    def x(self) -> builtins.float:
        r"""
        X coordinate in meters
        """
    @property
    def y(self) -> builtins.float:
        r"""
        Y coordinate in meters
        """
    @property
    def z(self) -> builtins.float:
        r"""
        Z coordinate in meters
        """
    @property
    def yaw(self) -> builtins.float:
        r"""
        Yaw angle in radians
        """
    def __new__(
        cls,
        x: builtins.float,
        y: builtins.float,
        z: builtins.float,
        yaw: builtins.float,
    ) -> CompressedStart: ...

@typing.final
class Console:
    r"""
    Access to the console subsystem

    The Crazyflie has a text console that is used to communicate various information
    and debug message to the ground.
    """
    async def get_lines(self) -> builtins.list[builtins.str]:
        r"""
        Get console lines as they arrive

        This function returns console lines line-by-line. It buffers lines internally
        and returns up to 100 lines per call with a 10ms timeout per line.

        The lib keeps track of the console history since connection, so the first
        call to this function will return all lines received since connection.

        Returns:
            List of console output lines (up to 100 with 10ms timeout)
        """

@typing.final
class Crazyflie:
    r"""
    Wrapper for the Crazyflie struct

    This provides a Python interface to the Rust Crazyflie implementation.
    All methods are async and return Python coroutines.
    """
    @staticmethod
    async def connect_from_uri(
        link_context: LinkContext,
        uri: builtins.str,
        toc_cache: typing.Optional[
            typing.Union[NoTocCache, InMemoryTocCache, FileTocCache]
        ] = None,
    ) -> Crazyflie:
        r"""
        Connect to a Crazyflie from a URI string

        Args:
            link_context: LinkContext instance for connection management
            uri: Connection URI (e.g., "radio://0/80/2M/E7E7E7E7E7")
            toc_cache: Optional TOC cache instance (NoTocCache, InMemoryTocCache, or FileTocCache)
                       If not provided, defaults to NoTocCache (no caching)

        Returns:
            Connected Crazyflie instance
        """
    async def disconnect(self) -> None:
        r"""
        Disconnect from the Crazyflie
        """
    def commander(self) -> Commander:
        r"""
        Get the commander subsystem
        """
    def console(self) -> Console:
        r"""
        Get the console subsystem
        """
    def high_level_commander(self) -> HighLevelCommander:
        r"""
        Get the high-level commander subsystem
        """
    def localization(self) -> Localization:
        r"""
        Get the localization subsystem
        """
    def memory(self) -> Memory:
        r"""
        Get the memory subsystem
        """
    def log(self) -> Log:
        r"""
        Get the log subsystem
        """
    def param(self) -> Param:
        r"""
        Get the param subsystem
        """
    def platform(self) -> Platform:
        r"""
        Get the platform subsystem
        """

@typing.final
class EmergencyControl:
    r"""
    Emergency control interface

    Provides emergency stop functionality that immediately stops all motors.
    """
    async def send_emergency_stop(self) -> None:
        r"""
        Send emergency stop command

        Immediately stops all motors and puts the Crazyflie into a locked state.
        The drone will require a reboot before it can fly again.
        """
    async def send_emergency_stop_watchdog(self) -> None:
        r"""
        Send emergency stop watchdog

        Activates/resets a watchdog failsafe that will automatically emergency stop
        the drone if this message isn't sent every 1000ms. Once activated by the first
        call, you must continue sending this periodically forever or the drone will
        automatically emergency stop. Use only if you need automatic failsafe behavior.
        """

@typing.final
class ExternalPose:
    r"""
    External pose interface

    Provides functionality to send external position and pose data from motion
    capture systems or other external tracking sources to the Crazyflie's
    onboard state estimator.
    """
    async def send_external_position(
        self, pos: typing.Sequence[builtins.float]
    ) -> None:
        r"""
        Send external position (x, y, z) to the Crazyflie

        Updates the Crazyflie's position estimate with 3D position data.

        # Arguments
        * `pos` - Position array [x, y, z] in meters
        """
    async def send_external_pose(
        self,
        pos: typing.Sequence[builtins.float],
        quat: typing.Sequence[builtins.float],
    ) -> None:
        r"""
        Send external pose (position + quaternion) to the Crazyflie

        Updates the Crazyflie's position estimate with full 6DOF pose data.
        Includes both position and orientation.

        # Arguments
        * `pos` - Position array [x, y, z] in meters
        * `quat` - Quaternion array [qx, qy, qz, qw]
        """

@typing.final
class FileTocCache:
    r"""
    File-based TOC cache that persists to disk

    This cache stores TOCs as individual JSON files in a specified directory.
    Each TOC is stored as {crc32}.json. The cache persists across Python process
    restarts, making it ideal for production use.

    The cache directory is created automatically if it doesn't exist.

    Example:
        context = LinkContext()
        cache = FileTocCache("/tmp/cf_toc_cache")
        cf = Crazyflie.connect_from_uri(context, "radio://0/80/2M/E7E7E7E7E7", toc_cache=cache)
    """
    def __new__(cls, cache_dir: builtins.str) -> FileTocCache:
        r"""
        Create a new FileTocCache instance

        Args:
            cache_dir: Directory path where TOC files will be stored
        """
    def clear(self) -> None:
        r"""
        Clear all cached TOC files
        """
    def size(self) -> builtins.int:
        r"""
        Get the number of cached TOCs (from memory cache)
        """
    def get_cache_dir(self) -> builtins.str:
        r"""
        Get the cache directory path
        """

@typing.final
class HighLevelCommander:
    r"""
    High-level commander subsystem wrapper
    """
    async def set_group_mask(self, group_mask: builtins.int) -> None:
        r"""
        Set the group mask for the high-level commander.

        # Arguments
        * `group_mask` - The group mask to set. Use `ALL_GROUPS` to set the mask for all Crazyflies.
        """
    async def take_off(
        self,
        height: builtins.float,
        yaw: typing.Optional[builtins.float],
        duration: builtins.float,
        group_mask: typing.Optional[builtins.int],
    ) -> None:
        r"""
        Take off vertically from the current x-y position to the given target height.

        # Arguments
        * `height` - Target height (meters) above the world origin.
        * `yaw` - Target yaw (radians). Use `None` to maintain the current yaw.
        * `duration` - Time (seconds) to reach the target height.
        * `group_mask` - Bitmask selecting which Crazyflies to command. Use `None` for all Crazyflies.
        """
    async def land(
        self,
        height: builtins.float,
        yaw: typing.Optional[builtins.float],
        duration: builtins.float,
        group_mask: typing.Optional[builtins.int],
    ) -> None:
        r"""
        Land vertically from the current x-y position to the given target height.

        # Arguments
        * `height` - Target height (meters) above the world origin.
        * `yaw` - Target yaw (radians). Use `None` to maintain the current yaw.
        * `duration` - Time (seconds) to reach the target height.
        * `group_mask` - Bitmask selecting which Crazyflies to command. Use `None` for all Crazyflies.
        """
    async def stop(self, group_mask: typing.Optional[builtins.int]) -> None:
        r"""
        Stop the current high-level command and disable motors.

        This immediately halts any active high-level command (takeoff, land, go_to, spiral,
        or trajectory execution) and stops motor output.

        # Arguments
        * `group_mask` - Bitmask selecting which Crazyflies to command. Use `None` for all Crazyflies.
        """
    async def go_to(
        self,
        x: builtins.float,
        y: builtins.float,
        z: builtins.float,
        yaw: builtins.float,
        duration: builtins.float,
        relative: builtins.bool,
        linear: builtins.bool,
        group_mask: typing.Optional[builtins.int],
    ) -> None:
        r"""
        Move to an absolute or relative position with smooth path planning.

        The path is designed to transition smoothly from the current state to the target
        position, gradually decelerating at the goal with minimal overshoot. When the
        system is at hover, the path will be a straight line, but if there is any initial
        velocity, the path will be a smooth curve.

        The trajectory is derived by solving for a unique 7th-degree polynomial that
        satisfies the initial conditions of position, velocity, and acceleration, and
        ends at the goal with zero velocity and acceleration. Additionally, the jerk
        (derivative of acceleration) is constrained to be zero at both the starting
        and ending points.

        # Arguments
        * `x` - Target x-position in meters
        * `y` - Target y-position in meters
        * `z` - Target z-position in meters
        * `yaw` - Target yaw angle in radians
        * `duration` - Time in seconds to reach the target position.
        * `relative` - If `true`, positions and yaw are relative to current position; if `false`, absolute
        * `linear` - If `true`, use linear interpolation; if `false`, use polynomial trajectory
        * `group_mask` - Bitmask selecting which Crazyflies to command. Use `None` for all Crazyflies.
        """
    async def spiral(
        self,
        angle: builtins.float,
        initial_radius: builtins.float,
        final_radius: builtins.float,
        altitude_gain: builtins.float,
        duration: builtins.float,
        sideways: builtins.bool,
        clockwise: builtins.bool,
        group_mask: typing.Optional[builtins.int],
    ) -> None:
        r"""
        Fly a spiral segment.

        The Crazyflie moves along an arc around a computed center point, sweeping
        through an angle of up to ±2π (one full turn). While sweeping, the radius
        changes linearly from `initial_radius` to `final_radius`. If the radii are
        equal, the path is a circular arc; if they differ, the path spirals inward
        or outward accordingly. Altitude changes linearly by `altitude_gain` over
        the duration.

        # Center placement
        The spiral center is placed differently depending on `sideways` and `clockwise`:
        * `sideways = false`
          * `clockwise = true`  → center lies to the **right** of the current heading.
          * `clockwise = false` → center lies to the **left** of the current heading.
        * `sideways = true`
          * `clockwise = true`  → center lies **ahead** of the current heading.
          * `clockwise = false` → center lies **behind** the current heading.

        # Orientation
        * `sideways = false`: the Crazyflie's heading follows the tangent of the
          spiral (flies forward along the path).
        * `sideways = true`: the Crazyflie's heading points toward the spiral center
          while circling around it (flies sideways along the path).

        # Direction conventions
        * `clockwise` chooses on which side the center is placed.
        * The **sign of `angle`** sets the travel direction along the arc:
          `angle > 0` sweeps one way; `angle < 0` traverses the arc in the opposite
          direction (i.e., "backwards"). This can make some combinations appear
          counterintuitive—for example, `sideways = false`, `clockwise = true`,
          `angle < 0` will *look* counter-clockwise from above.

        # Arguments
        * `angle` - Total spiral angle in radians (limited to ±2π).
        * `initial_radius` - Starting radius in meters (≥ 0).
        * `final_radius` - Ending radius in meters (≥ 0).
        * `altitude_gain` - Vertical displacement in meters (positive = climb,
          negative = descent).
        * `duration` - Time in seconds to complete the spiral.
        * `sideways` - If `true`, heading points toward the spiral center;
          if `false`, heading follows the spiral tangent.
        * `clockwise` - If `true`, fly clockwise; otherwise counter-clockwise.
        * `group_mask` - Bitmask selecting which Crazyflies this applies to.
        """
    async def define_trajectory(
        self,
        trajectory_id: builtins.int,
        memory_offset: builtins.int,
        num_pieces: builtins.int,
        trajectory_type: typing.Optional[builtins.int],
    ) -> None:
        r"""
        Define a trajectory previously uploaded to memory.

        # Arguments
        * `trajectory_id` - Identifier used to reference this trajectory later.
        * `memory_offset` - Byte offset into trajectory memory where the data begins.
        * `num_pieces` - Number of segments (pieces) in the trajectory.
        * `trajectory_type` - Type of the trajectory data (e.g. Poly4D).
        """
    async def start_trajectory(
        self,
        trajectory_id: builtins.int,
        time_scale: builtins.float,
        relative_position: builtins.bool,
        relative_yaw: builtins.bool,
        reversed: builtins.bool,
        group_mask: typing.Optional[builtins.int],
    ) -> None:
        r"""
        Start executing a previously defined trajectory.

        The trajectory is identified by `trajectory_id` and can be modified
        at execution time by scaling its speed, shifting its position, aligning
        its yaw, or running it in reverse.

        # Arguments
        * `trajectory_id` - Identifier of the trajectory (as defined with [`HighLevelCommander::define_trajectory`]).
        * `time_scale` - Time scaling factor; `1.0` = original speed,
          values >1.0 slow down, values <1.0 speed up.
        * `relative_position` - If `true`, shift trajectory to the current setpoint position.
        * `relative_yaw` - If `true`, align trajectory yaw to the current yaw.
        * `reversed` - If `true`, execute the trajectory in reverse.
        * `group_mask` - Mask selecting which Crazyflies this applies to.
          If `None`, defaults to all Crazyflies.
        """

@typing.final
class InMemoryTocCache:
    r"""
    In-memory TOC cache using a HashMap

    This cache stores TOCs in memory for fast access. The cache is lost when the
    Python process exits. Multiple Crazyflie connections can share the same cache
    instance for improved performance.

    Example:
        context = LinkContext()
        cache = InMemoryTocCache()
        cf1 = Crazyflie.connect_from_uri(context, "radio://0/80/2M/E7E7E7E7E7", toc_cache=cache)
        cf2 = Crazyflie.connect_from_uri(context, "radio://0/80/2M/E7E7E7E7E8", toc_cache=cache)
    """
    def __new__(cls) -> InMemoryTocCache:
        r"""
        Create a new InMemoryTocCache instance
        """
    def clear(self) -> None:
        r"""
        Clear all cached TOCs
        """
    def size(self) -> builtins.int:
        r"""
        Get the number of cached TOCs
        """

@typing.final
class Lighthouse:
    r"""
    Lighthouse positioning system interface

    Provides functionality to receive lighthouse sweep angle data and manage
    lighthouse base station configuration persistence.
    """
    async def get_angle_data(self) -> builtins.list[LighthouseAngleData]:
        r"""
        Get lighthouse angle measurements as they arrive

        This function returns lighthouse angle data for base stations. It buffers data internally
        and returns up to 100 angle measurements per call with a 10ms timeout per measurement.

        To receive angle data, you must first enable the angle stream by setting the parameter
        `locSrv.enLhAngleStream` to 1.

        The lib keeps track of angle data since the stream was enabled, so the first
        call to this function will return all measurements received since the stream was enabled.

        Returns:
            List of LighthouseAngleData (up to 100 with 10ms timeout)
        """
    async def persist_lighthouse_data(
        self,
        geo_list: typing.Sequence[builtins.int],
        calib_list: typing.Sequence[builtins.int],
    ) -> builtins.bool:
        r"""
        Persist lighthouse geometry and calibration data to permanent storage

        Sends a command to persist lighthouse geometry and/or calibration data
        to permanent storage in the Crazyflie, then waits for confirmation.
        The geometry and calibration data must have been previously written to
        RAM via the memory subsystem.

        # Arguments
        * `geo_list` - List of base station IDs (0-15) for which to persist geometry data
        * `calib_list` - List of base station IDs (0-15) for which to persist calibration data

        # Returns
        * `True` if data was successfully persisted
        * `False` if persistence failed
        """

@typing.final
class LighthouseAngleData:
    r"""
    Lighthouse angle sweep data
    """
    @property
    def base_station(self) -> builtins.int:
        r"""
        Base station ID
        """
    @property
    def angles(self) -> LighthouseAngles:
        r"""
        Angle measurements
        """

@typing.final
class LighthouseAngles:
    r"""
    Lighthouse sweep angles for all 4 sensors
    """
    @property
    def x(self) -> builtins.list[builtins.float]:
        r"""
        Horizontal angles for 4 sensors [rad]
        """
    @property
    def y(self) -> builtins.list[builtins.float]:
        r"""
        Vertical angles for 4 sensors [rad]
        """

@typing.final
class LinkContext:
    r"""
    Link context for scanning and discovering Crazyflies

    The LinkContext provides methods to scan for available Crazyflies on the network.
    It can scan on specific addresses or use the default broadcast address.

    Example:
        context = LinkContext()
        uris = await context.scan()  # Scan on default address E7E7E7E7E7
        for uri in uris:
            print(f"Found: {uri}")
    """
    def __new__(cls) -> LinkContext: ...
    async def scan(
        self, address: typing.Optional[typing.Sequence[builtins.int]] = None
    ) -> builtins.list[builtins.str]:
        r"""
        Scan for Crazyflies on a specific address

        # Arguments
        * `address` - Optional 5-byte address to scan (defaults to [0xE7, 0xE7, 0xE7, 0xE7, 0xE7])

        # Returns
        List of URIs found
        """

@typing.final
class Localization:
    r"""
    Localization subsystem wrapper
    """
    def emergency(self) -> EmergencyControl:
        r"""
        Get the emergency control interface
        """
    def external_pose(self) -> ExternalPose:
        r"""
        Get the external pose interface
        """
    def lighthouse(self) -> Lighthouse:
        r"""
        Get the lighthouse interface
        """
    def loco_positioning(self) -> LocoPositioning:
        r"""
        Get the loco positioning interface
        """

@typing.final
class LocoPositioning:
    r"""
    Loco Positioning System (UWB) interface

    Provides functionality to send Loco Positioning Protocol (LPP) packets
    to ultra-wide-band positioning nodes.
    """
    async def send_short_lpp_packet(
        self, dest_id: builtins.int, data: typing.Sequence[builtins.int]
    ) -> None:
        r"""
        Send Loco Positioning Protocol (LPP) packet to a specific destination

        # Arguments
        * `dest_id` - Destination node ID
        * `data` - LPP packet payload
        """

@typing.final
class Log:
    r"""
    Access to the Crazyflie Log Subsystem

    This struct provides functions to interact with the Crazyflie Log subsystem.
    """
    def names(self) -> builtins.list[builtins.str]:
        r"""
        Get the names of all the log variables

        The names contain group and name of the log variable formatted as
        "group.name".
        """
    def get_type(self, name: builtins.str) -> builtins.str:
        r"""
        Return the type of a log variable or an Error if the parameter does not exist.

        Args:
            name: Log variable name

        Returns:
            Type as string (e.g., "u8", "i16", "f32")
        """
    async def create_block(self) -> LogBlock:
        r"""
        Create a Log block

        This will create a log block in the Crazyflie firmware and return a
        LogBlock object that can be used to add variable to the block and start
        logging

        This function can fail if there is no more log block ID available: each
        log block is assigned a 8 bit ID by the lib and so far they are not
        re-used. So during a Crazyflie connection lifetime, up to 256 log
        blocks can be created. If this becomes a problem for any use-case, it
        can be solved by a more clever ID generation algorithm.

        The Crazyflie firmware also has a limit in number of active log block,
        this function will fail if this limit is reached. Unlike for the ID, the
        active log blocks in the Crazyflie are cleaned-up when the LogBlock
        object is dropped.

        Returns:
            A new LogBlock instance that can have variables added to it
        """

@typing.final
class LogBlock:
    r"""
    Log Block

    This object represents an IDLE LogBlock in the Crazyflie.

    If the LogBlock object is dropped or its associated LogStream, the
    Log Block will be deleted in the Crazyflie freeing resources.
    """
    async def add_variable(self, name: builtins.str) -> None:
        r"""
        Add a variable to the log block

        A packet will be sent to the Crazyflie to add the variable. The variable is logged in the same format as
        it is stored in the Crazyflie (ie. there is no conversion done)

        This function can fail if the variable is not found in the toc or of the Crazyflie returns an error
        The most common error reported by the Crazyflie would be if the log block is already too full.

        Args:
            name: Variable name (e.g., "stateEstimate.roll")
        """
    async def start(self, period_ms: builtins.int) -> LogStream:
        r"""
        Start log block and return a stream to read the value

        Since a log-block cannot be modified after being started, this function
        consumes the LogBlock object and return a LogStream. The function
        LogStream.stop() can be called on the LogStream to get back the LogBlock object.

        This function can fail if there is a protocol error or an error
        reported by the Crazyflie. In such case, the LogBlock object will be
        dropped and the block will be deleted in the Crazyflie

        Args:
            period_ms: Sampling period in milliseconds (10-2550)

        Returns:
            A LogStream for reading data
        """

@typing.final
class LogStream:
    r"""
    Log Stream

    This object represents a started log block that is currently returning data
    at regular intervals.

    Dropping this object or the associated LogBlock will delete the log block
    in the Crazyflie.
    """
    async def next(self) -> dict[str, int | dict[str, int | float]]:
        r"""
        Get the next log data from the log block stream

        This function will wait for the data and only return a value when the
        next data is available.

        This function will return an error if the Crazyflie gets disconnected.

        Returns:
            Dictionary with timestamp and variable values
        """
    async def stop(self) -> LogBlock:
        r"""
        Stops the log block from streaming

        This method consumes the stream and returns back the log block object so that it can be started again later
        with a different period.

        This function can only fail on unexpected protocol error. If it does, the log block is dropped and will be
        cleaned-up next time a log block is created.

        Returns:
            The original LogBlock that can be restarted
        """

@typing.final
class Memory:
    r"""
    Memory subsystem wrapper.

    Provides methods to upload trajectory data to the Crazyflie.
    Access via `cf.memory()`.
    """
    async def write_trajectory(
        self, trajectory: typing.Sequence[Poly4D], start_addr: builtins.int = 0
    ) -> int:
        r"""
        Write an uncompressed (Poly4D) trajectory to the Crazyflie.

        Opens the trajectory memory, writes all segments, and closes
        the memory. Returns the number of bytes written.

        # Arguments
        * `trajectory` - List of Poly4D segments to upload
        * `start_addr` - Address in trajectory memory (default 0)
        """
    async def write_compressed_trajectory(
        self,
        start: CompressedStart,
        segments: typing.Sequence[CompressedSegment],
        start_addr: builtins.int = 0,
    ) -> int:
        r"""
        Write a compressed trajectory to the Crazyflie.

        Opens the trajectory memory, writes the start point followed
        by all compressed segments, and closes the memory.
        Returns the number of bytes written.

        # Arguments
        * `start` - CompressedStart defining the initial position
        * `segments` - List of CompressedSegment instances
        * `start_addr` - Address in trajectory memory (default 0)
        """

@typing.final
class NoTocCache:
    r"""
    No-op TOC cache that doesn't store anything

    This is the default cache used when no cache is provided to connect_from_uri.
    It provides no caching functionality, meaning TOCs will be downloaded on every connection.
    """
    def __new__(cls) -> NoTocCache:
        r"""
        Create a new NoTocCache instance
        """

@typing.final
class Param:
    r"""
    Access to the Crazyflie Param Subsystem

    This struct provides methods to interact with the parameter subsystem.

    The Crazyflie exposes a param subsystem that allows to easily declare parameter
    variables in the Crazyflie and to discover, read and write them from the ground.

    Variables are defined in a table of content that is downloaded upon connection.
    Each param variable have a unique name composed from a group and a variable name.
    Functions that accesses variables, take a `name` parameter that accepts a string
    in the format "group.variable"

    During connection, the full param table of content is downloaded form the
    Crazyflie as well as the values of all the variable. If a variable value
    is modified by the Crazyflie during runtime, it sends a packet with the new
    value which updates the local value cache.
    """
    def names(self) -> builtins.list[builtins.str]:
        r"""
        Get the names of all the parameters

        The names contain group and name of the parameter variable formatted as
        "group.name".
        """
    def get_type(self, name: builtins.str) -> builtins.str:
        r"""
        Get the type of a parameter

        Returns the type string of the parameter (e.g., "u8", "f32", "i16").

        # Arguments
        * `name` - Parameter name in format "group.name"

        # Returns
        String representing the parameter type
        """
    async def get(self, name: builtins.str) -> int | float:
        r"""
        Get param value

        Get value of a parameter. This function takes the value from a local
        cache and so is quick.

        # Arguments
        * `name` - Parameter name in format "group.name"

        # Returns
        Parameter value (int or float depending on parameter type)
        """
    async def set(self, name: builtins.str, value: int | float) -> None:
        r"""
        Set a parameter value

        Sets a parameter to the given value. The value is automatically converted
        to match the parameter's type. Returns an error if the parameter does not
        exist or if the value cannot be converted to the parameter's type without
        loss of information.

        # Arguments
        * `name` - Parameter name in format "group.name"
        * `value` - New parameter value (int or float)

        # Errors
        Returns an error if:
        - The parameter does not exist
        - The value is out of range for the parameter type
        - The value cannot be represented accurately (e.g., fractional value for integer param)
        """

@typing.final
class Platform:
    r"""
    Access to platform services

    The platform CRTP port hosts a couple of utility services. This range from fetching the version of the firmware
    and CRTP protocol, communication with apps using the App layer to setting the continuous wave radio mode for
    radio testing.
    """
    async def get_protocol_version(self) -> builtins.int:
        r"""
        Fetch the protocol version from the Crazyflie

        The protocol version is updated when new message or breaking change are
        implemented in the protocol.
        Compatibility is checked at connection time.
        """
    async def get_firmware_version(self) -> builtins.str:
        r"""
        Fetch the firmware version

        If this firmware is a stable release, the release name will be returned for example ```2021.06```.
        If this firmware is a git build, between releases, the number of commit since the last release will be added
        for example ```2021.06 +128```.
        """
    async def get_device_type_name(self) -> builtins.str:
        r"""
        Fetch the device type.

        The Crazyflie firmware can run on multiple device. This function returns the name of the device. For example
        ```Crazyflie 2.1``` is returned in the case of a Crazyflie 2.1.
        """
    async def set_continuous_wave(self, activate: builtins.bool) -> None:
        r"""
        Set radio in continuous wave mode

        If activate is set to true, the Crazyflie's radio will transmit a continuous wave at the current channel
        frequency. This will be active until the Crazyflie is reset or this function is called with activate to false.

        Setting continuous wave will:
         - Disconnect the radio link. So this function should practically only be used when connected over USB
         - Jam any radio running on the same frequency, this includes Wifi and Bluetooth

        As such, this shall only be used for test purpose in a controlled environment.
        """
    async def send_arming_request(self, do_arm: builtins.bool) -> None:
        r"""
        Send system arm/disarm request

        Arms or disarms the Crazyflie's safety systems. When disarmed, the motors
        will not spin even if thrust commands are sent.

        # Arguments
        * `do_arm` - true to arm, false to disarm
        """
    async def send_crash_recovery_request(self) -> None:
        r"""
        Send crash recovery request

        Requests recovery from a crash state detected by the Crazyflie.
        """
    async def get_app_channel(self) -> typing.Optional[AppChannel]:
        r"""
        Get the bidirectional app channel for custom communication

        The app channel allows bidirectional communication between ground software
        and custom apps running on the Crazyflie. This is useful for implementing
        custom protocols without defining new CRTP packets.

        Note: This channel can only be acquired once per connection. Subsequent
        calls will return None.

        # Returns
        * Optional AppChannel object, or None if already acquired
        """

@typing.final
class Poly:
    r"""
    A polynomial with up to 8 coefficients.

    Coefficients beyond the provided values are zero-filled.
    If more than 8 values are provided, only the first 8 are used.
    """
    @property
    def values(self) -> builtins.list[builtins.float]:
        r"""
        Get the coefficient values as a list
        """
    def __new__(cls, values: typing.Sequence[builtins.float]) -> Poly: ...

@typing.final
class Poly4D:
    r"""
    An uncompressed 4D polynomial trajectory segment.

    Each segment defines motion along x, y, z, and yaw axes
    using 8th-order polynomials over a given duration.
    Packs to 132 bytes.
    """
    @property
    def duration(self) -> builtins.float:
        r"""
        Duration of this segment in seconds
        """
    @property
    def x(self) -> Poly:
        r"""
        X polynomial
        """
    @property
    def y(self) -> Poly:
        r"""
        Y polynomial
        """
    @property
    def z(self) -> Poly:
        r"""
        Z polynomial
        """
    @property
    def yaw(self) -> Poly:
        r"""
        Yaw polynomial
        """
    def __new__(
        cls, duration: builtins.float, x: Poly, y: Poly, z: Poly, yaw: Poly
    ) -> Poly4D: ...
